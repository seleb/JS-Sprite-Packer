<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>JS Sprite Utility</title>

  <style>
  html, body{
  	padding:0;
  	margin:0;
  	background:#334;
  	font-size: 0.75em;
  }
  html body *{
  	font-family: Century Gothic, Arial, sans-serif;
  	color:#FFF;
  }

  h1{
  	margin:0;
  	padding:0.5rem 0;
  	text-shadow:
  	#112 0px 2px 0px;

  	margin-bottom: 0.5em;
  	border-bottom: solid 1px #445;
  	position: relative;
  }
  h1:before{
  	content: ' ';
  	bottom:1px;
  	border-bottom: solid 2px #112;
  	left:0;
  	right:0;
  	bottom:0;
  	top:0;
  	position: absolute;
  }

  #page{
  	width:100%;
  	max-width: 800px;
  	margin:auto;
  }

  main, header{
  	width:100%;
  }

  section{
  	display:inline-block;
  	vertical-align: top;
  	width:50%;
  }
  section h2{
  	padding:0.5em;
  	margin:0;
  	text-shadow:
  	#112 0px 2px 0px;
  }

  canvas, img, ul li div{
  	image-rendering:pixelated;
  	background: #112;
  	border:1px solid #334;
  	border-style: groove;
  }

  #work-area{
  	display:none;
  }

  button{
  	background-color: #112;
  	border-color: #334;
  	border-style: groove;
  	cursor:pointer;
  	/*background: #797D48;
  	border-radius: 50%;
  	font-weight: bolder;
  	color: #FFF;
  	text-shadow:
  	#18190E 0px -1px 0px;
  	border:0;
  	padding:0.5em;*/
  }
  button:hover{
  	background: #334;
  	text-shadow:
  	#957964 0px -1px 0px;
  	border-style: ridge;
  }

  input, textarea{
  	background: #112;
  	border-color: #334;
  	border-style: groove;
  }

  ul, code{
  	display:block;
  	max-height: 25em;
  	overflow-y: auto;
  }
  ul li div{
  	width:25px;
  	height:25px;
  	text-align: center;
  	display:inline-block;
  	vertical-align: middle;

  	background-position: center center;
  	background-repeat: no-repeat no-repeat;
  	background-size: contain;
  }
  ul li span{
    width: 20em;
    display: inline-block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  </style>

<script>

function Sprite(_url, _file){
	this.img = new Image();
	this.img.src = _url;
	this.name = _file.name;
}

Sprite.prototype.getArea = function(){
	return this.img.width * this.img.height;
}

Sprite.prototype.trim = function(){
	var canvas = document.createElement("canvas");
	var ctx = canvas.getContext("2d");
	canvas.width = this.img.width;
	canvas.height = this.img.height;
	ctx.drawImage(this.img,0,0);

	var imgData = ctx.getImageData(0,0,canvas.width,canvas.height);

	// find first non-transparent pixel from top-left
	var start = {x:imgData.width,y:imgData.height};
	for(var y = 0; y < imgData.height; ++y){
		for(var x = 0; x < imgData.width; ++x){
			var p = y*imgData.width + x;
			var a = imgData.data[p*4 + 3];
			if(a > 0 && start.x > x){
				start.x = x;
			}if(a > 0 && start.y > y){
				start.y = y;
			}
		}
	}

	// find first non-transparent pixel from bottom-right
	var end = {x:0,y:0};
	for(var y = imgData.height-1; y > 0; --y){
		for(var x = imgData.width-1; x > 0; --x){
			var p = (y*canvas.width + x)*4;
			var a = imgData.data[p + 3];
			if(a > 0 && end.x < x){
				end.x = x;
			}if(a > 0 && end.y < y){
				end.y = y;
			}
		}
	}

	// resize canvas and draw image from first non-transparent pixel to last
	var size = {x: end.x+1 - start.x, y: end.y+1 - start.y};
	canvas.width = size.x;
	canvas.height = size.y;
	ctx.drawImage(this.img, start.x, start.y, size.x, size.y, 0,0, size.x, size.y);

	// overwrite image with the canvas output
	this.img.src = canvas.toDataURL();
}

function MyApp(){
	this.appName = "test";
	this.sprites = [];
	this.canvas = document.getElementById("canvas");
	this.ctx = this.canvas.getContext("2d");
	this.ctx.imageSmoothingEnabled = false;
}

MyApp.prototype.onImageLoaded = function(event){
	var sprite = new Sprite(event.target.result, event.target.file);
	this.sprites.push(sprite);

	var img = document.createElement("div");
	img.style.backgroundImage = "url('" + sprite.img.src + "')";
	var span = document.createElement("span");
	span.innerHTML = sprite.name;

	var li = document.createElement("li");
	var butt = document.createElement("button");
	butt.innerHTML = "X";
	butt.onclick = this.removeSprite.bind(this, sprite);
	li.appendChild(img);
	li.appendChild(span);
	li.appendChild(butt);
	document.getElementById("file-list").appendChild(li);
}
MyApp.prototype.removeSprite = function(_sprite){
	var idx = this.sprites.indexOf(_sprite);
	var fileList = document.getElementById("file-list");
	fileList.removeChild(fileList.childNodes[idx]);
	this.sprites.splice(idx, 1);
}

MyApp.prototype.init = function(){
	// check for API support
	if(!(window.File && window.FileReader && window.FileList && window.Blob)){
		throw "File API unsupported";
	}
	document.getElementById("files").onchange = this.handleFileSelect.bind(this);
	console.log("initialized");
}
MyApp.prototype.loadImage = function(file){
	var reader = new FileReader();
	reader.file = file;
	reader.onload = this.onImageLoaded.bind(this);
	reader.readAsDataURL(file);
}
MyApp.prototype.handleFileSelect = function(event){
	event.stopPropagation();
	event.preventDefault();

	var files = event.target.files;
	var output = [];
	for(var i = 0; i < files.length; ++i){
		var f = files[i];
		this.loadImage(f);
	}
}
MyApp.prototype.trim = function(){
	for(var i = 0; i < this.sprites.length; ++i){
		this.sprites[i].trim();
	}
}
MyApp.prototype.areaSort = function(a,b){
	return b.getArea() - a.getArea();
}
MyApp.prototype.layout = function(){
	// if there aren't any sprites, return early
	if(this.sprites.length == 0){
		document.getElementById("output-img").src = "no_img.png";
		document.getElementById("output-json").innerHTML = "[]";
		return;
	}

	// copy the array so we don't mess up the file list
	var spritesCopy = this.sprites.slice();

	// sort sprites by area
	spritesCopy.sort(this.areaSort);

	var padding = parseInt(document.getElementById("padding").value,10);

	var json = [];

	// calculate total area covered by sprites
	var area = 0;
	for(var i = 0; i < spritesCopy.length; ++i){
		area += spritesCopy[i].getArea();
	}

	// start with a power-of-2 square with at least enough area for every sprite
	// (no point trying to arrange within an area which is too small)
	this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
	this.canvas.width = 2;
	while(this.canvas.width * this.canvas.width < area){
		this.canvas.width *= 2;
	}
	this.canvas.height = this.canvas.width;

	// place every sprite
	sprite_loop:
	for(var i = 0; i < spritesCopy.length; ++i){
		var sprite = spritesCopy[i];
		var start = {x:padding,y:padding};
		var imgData = this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height).data;
		var valid = false;
		do{
			// searches for the first open pixel from the top-left
			var imgData = this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height).data;
			outer_loop:
			for(var y = start.y; y < this.canvas.height-sprite.img.height-padding; ++y){
			for(var x = start.x; x < this.canvas.width-sprite.img.width-padding; ++x){
				var p = (y*this.canvas.width + x)*4;
				if(imgData[p+3] == 0){
					start.x = x;
					start.y = y;
					valid = true;
					break outer_loop;
				}
			}
			}

			// if we couldn't find an open pixel, double the workspace and start over
			if(!valid){
				this.canvas.width *= 2;
				this.canvas.height *= 2;
				this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
				json = [];

				i = -1;
				console.log("Failed attempt: resizing to " + this.canvas.width);
				continue sprite_loop;
			}

			
			// check if the sprite would overlap with anything in the workspace if placed at the given location
			valid = true;
			outer_loop:
			for(var y = 0; y < sprite.img.height; ++y){
			for(var x = 0; x < sprite.img.width; ++x){
				var p = ((start.y + y)*this.canvas.width + (start.x + x))*4;
				if(imgData[p+3] != 0){
					valid = false;
					if(start.x < this.canvas.width-sprite.img.width-padding){
						// move one to the right
						start.x += 1;
					}else{
						// move one down and all the way to the left
						start.y += 1;
						start.x = 0;
					}
					break outer_loop;
				}
			}
			}
		}while(!valid);
		
		// draw a rectangle where the sprite will be placed
		this.ctx.fillStyle = 'rgb(255,'+Math.floor(Math.random()*256)+','+Math.floor(Math.random()*256)+')';
		this.ctx.strokeStyle = 'rgba(0,0,0,255)'
		this.ctx.fillRect(start.x,start.y, sprite.img.width, sprite.img.height);
		
		if(padding > 0){
			this.ctx.lineWidth = padding;
			this.ctx.strokeRect(start.x-padding/2,start.y-padding/2, sprite.img.width+padding, sprite.img.height+padding);
		}
		// save the sprite entry into json
		var jsonEntry = {
			id: sprite.name,
			x: start.x,
			y: start.y,
			w: sprite.img.width,
			h: sprite.img.height
		};
		json.push(jsonEntry);
	}

	// replace workspace with actual sprites
	//this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
	for(var i = 0; i < json.length; ++i){
		var entry = json[i];
		this.ctx.drawImage(spritesCopy[i].img,entry.x,entry.y);
	}

	document.getElementById("output-img").src = this.canvas.toDataURL();
	document.getElementById("output-json").innerHTML = JSON.stringify(json);
}

var app = null;
document.addEventListener("DOMContentLoaded", function(event) { 
app = new MyApp();
app.init();
});
</script>
</head>

<body>
<div id="page">
<header>
<h1>JS Sprite Utility</h1>
</header>

<main role="main">
<section>
<h2>Input</h2>
<label>File input: <input type="file" id="files" name="files[]" multiple/></label>
<br>
<label>Padding: <input type="number" id="padding" name="padding" value="1" min="0"/>px</label>
<br>
<button onclick="app.trim();app.layout();">Go</button>
<br>
<label>Sprites:<ul id="file-list"></ul></label>

</section><!-- 

 --><section id="work-area">
<h2>Work Area</h2>
<canvas id="canvas"></canvas>
</section><!-- 

 --><section>
<h2>Output</h2>
<img id="output-img" src="no_img.png"></img>
<br>
<label>JSON:<code id="output-json">[]</code></label>
</section>
</main>
</div>
</body>

</html>